import swpag_client
import signal
import os
import argparse
import time
import sys
import threading
import logger
from subprocess import Popen
module_logger = logger.create_logger('$cript_k!ddie_CTF_Flag_Collection')

module_description = '''
$cript_k!ddie N/W Sniffer

N/W Sniffer that operates using tcpdump and Python Threads

Collects TCP Requests where the flags have been compromised. 

This can help extract data from traffic according to ticks and flags are filtered in this.

'''
PROCESS_KILL_TIME = 2*60*60
TICK_DURATION = 3*60
DEFAULT_OUTPUT_DIRECTORY = 'Output/'
DEFAULT_NETWORK_INTERFACE = 'lo'

arguement_parser = argparse.ArgumentParser(
    formatter_class=argparse.RawDescriptionHelpFormatter, description=module_description)

arguement_parser.add_argument(
    '-o', '--output_dir', help="Directory you want the output of the dump. Default is /Output",default=DEFAULT_OUTPUT_DIRECTORY)
arguement_parser.add_argument(
    'game_interface_url', help='Your Swpag_client Game Interface URL. Dont Forget Http')
arguement_parser.add_argument(
    'auth_token', help='Your Swpag_client Auth Token')
arguement_parser.add_argument(
    '-i','--interface', help='Name of Interface. Eg. eth0 / lo',default=DEFAULT_NETWORK_INTERFACE)


class CTF_TCP_DUMP(threading.Thread):
    def __init__(self, tick_num, port, interface=DEFAULT_NETWORK_INTERFACE, output_folder=DEFAULT_OUTPUT_DIRECTORY):
        threading.Thread.__init__(self)
        self.interface = interface
        self.port = port
        self.output_folder = output_folder
        self.subprocess = None
        self.kill = False
        self.tick_num = tick_num
        self.output_path = None

    def kill_process(self):
        self.kill = True

    def run(self):
        output_path = self.output_folder + str(self.tick_num)+"__"+str(self.port)+'.pcap'
        self.output_path = output_path
        dump_command = "tcpdump -i {interface} port {port} -w {output_path}".format(
            interface=self.interface, port=self.port, output_path=output_path)
        self.subprocess = Popen(dump_command.split(' '))
        while True:
            # module_logger.info('Process Not Dead')
            if self.kill:
                module_logger.info('Killing Subprocesss %d', self.tick_num)
                pid = self.subprocess.pid
                os.kill(pid, signal.SIGINT)
                break



def run_service(TeamClient, interface=DEFAULT_NETWORK_INTERFACE,output_directory=DEFAULT_OUTPUT_DIRECTORY):
    status_object = TeamClient.get_team_status()
    team_name = status_object['team']['name']
    module_logger.info("Hello Team : %s. ",team_name)
    services = TeamClient.get_service_list()
    while True:
        current_tick = TeamClient.get_tick_info()
        module_logger.info("New Tick Has Started %s",str(current_tick['tick_id']))
        ctf_threads = []
        for service in services:
            # Create Process Threads
            x = CTF_TCP_DUMP(
                current_tick['tick_id'], service['port'], interface=interface)
            x.start()
            ctf_threads.append(x)
        time.sleep(current_tick['approximate_seconds_left']+1)
        for service in services:
            x = ctf_threads.pop()
            x.kill_process()


if __name__ == '__main__':
    parsed_arguments = arguement_parser.parse_args()
    if parsed_arguments.game_interface_url is None or parsed_arguments.auth_token is None:
        module_logger.error(arguement_parser.usage)
        exit()
    try : 
        TeamClient = swpag_client.Team(parsed_arguments.game_interface_url, parsed_arguments.auth_token)
        TeamClient.get_game_status()
        run_service(TeamClient,parsed_arguments.interface,parsed_arguments.output_dir)
    except:
        module_logger.error("Game Client Not Connecting")
        exit()
